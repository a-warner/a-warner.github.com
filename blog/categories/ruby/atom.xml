<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Least Astonished]]></title>
  <link href="http://www.leastastonished.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://www.leastastonished.com/"/>
  <updated>2014-08-27T08:28:37-04:00</updated>
  <id>http://www.leastastonished.com/</id>
  <author>
    <name><![CDATA[Andrew Warner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Beware the Siren Song of Comments]]></title>
    <link href="http://www.leastastonished.com/blog/2014/08/20/beware-the-siren-song-of-comments/"/>
    <updated>2014-08-20T08:53:27-04:00</updated>
    <id>http://www.leastastonished.com/blog/2014/08/20/beware-the-siren-song-of-comments</id>
    <content type="html"><![CDATA[<p>Developers love comments! Everyone who writes a comment thinks
that they&rsquo;re making a <a href="http://en.wikipedia.org/wiki/Pareto_efficiency">pareto improvement</a> to the codebase, when
in fact it&rsquo;s quite the opposite. Comments are especially dangerous because there are many situations where it
<em>seems</em> like a comment will help, but beware the siren&rsquo;s call!</p>

<p>I hate reading articles that make abstract arguments, so enough bloviating, let&rsquo;s check out some examples.
Here are some concrete uses of comments that I&rsquo;ve seen a lot, and how they can be easily avoided.</p>

<!-- more -->


<h3>Explaining some code</h3>

<p>You might want to write a comment to explain some code that isn&rsquo;t 100% intuitive. Let&rsquo;s
take a practical example from the <a href="http://genius.com">Genius</a> codebase:</p>

<pre><code class="ruby">class Artist &lt; ActiveRecord::Base
  before_save :set_canonical_name_changed

  private

  def set_canonical_name_changed
    self.canonical_name_changed = !!canonical_name.try(:name_changed?)
    nil # return nil because if canonical_name is unchanged, it'll return false, which halts save!
  end
end
</code></pre>

<p>That comment helpfully explains that <code>ActiveRecord</code> will halt saving a model if one of the callbacks returns
<code>false</code>. So, we have to return <code>nil</code> instead. Whenever you&rsquo;re tempted to comment your code to explain what&rsquo;s going on,
the code isn&rsquo;t clear enough. Your goal should be to make the code readable on its own.
So how can we make this section clearer without a comment? Why not just write a helpful method which explains
what&rsquo;s going on, and can be easily reused?</p>

<pre><code class="ruby">ActiveRecord::Base.class_eval do
  def without_halting_save
    yield
    nil
  end
end

class Artist &lt; ActiveRecord::Base
  before_save :set_canonical_name_changed

  private

  def set_canonical_name_changed
    without_halting_save do
      self.canonical_name_changed = !!canonical_name.try(:name_changed?)
    end
  end
end
</code></pre>

<p>Now we have the same amount of information, and a reusable method that explains its intent. Plus, now if
<code>ActiveRecord</code> changes its behavior, and returning nil suddenly starts halting save, we can change this method
and <a href="http://en.wikipedia.org/wiki/A_rising_tide_lifts_all_boats">lift all boats</a>.</p>

<h3>Explaining some performance hack</h3>

<p>Most of the time you can write readable code without worrying about performance, but sometimes performance
actually matters. When you have to write a performance hack, you might have an urge to write a comment explaining
why. The instinct to want to document your performance hack is the right one, but a comment is the wrong place.
Why? Because the hacky code might get modified, removed, or moved somewhere else, and the person who does that
has to remember to update the comment too. (Spoiler alert: they&rsquo;re not going to do it.) The comment will never
&ldquo;break&rdquo; and force someone to fix it if the behavior of the hack changes, it will just stick around to confuse
future programmers.</p>

<p>The right place to document hacks is a commit message. A commit message is easily accessible
to programmers wanting to edit the code, but it doesn&rsquo;t clog up the code and make
it harder to read. <code>git blame</code> allows you to see the commit message for any line that you&rsquo;re looking at.
Unlike comments, commit messages will never become out of date, because if the line that they&rsquo;re modifying gets deleted or modified, the commit message gets automatically &ldquo;removed&rdquo; from your view in <code>git blame</code>.</p>

<p>On any long-running project, your source control <em>is</em> your documentation. Disciplined development teams strive to
write code that, as much as possible, is self-documenting. When some code doesn&rsquo;t speak for itself, they leave
their notes in commit messages. If there is any additional discussion over some implementation detail or code
design in a pull request, it should be easy to find it right from source control.
<a href="http://www.leastastonished.com/blog/2014/03/06/git-getpull-quickly-find-the-pull-request-that-merged-your-commit-to-master/">git getpull</a>
allows you to find the GitHub pull request that merged the commit you&rsquo;re looking at, so you can quickly look
for any technical discussion about some implementation.</p>

<p>When I&rsquo;m writing a performance hack, I typically wrap it in a method explaining that it&rsquo;s a hack, and then write
a more detailed explanation in the commit message. For example, let&rsquo;s say I&rsquo;ve written some fast array compare
based on some specific knowledge of a data structure:</p>

<pre><code class="ruby">
def some_complex_calculation_method(input_array)
  if compare_input_with_stored_values_performance_hack(self.stored_array, input_array)
    # ... something ...
  end
end

def compare_input_with_stored_values_performance_hack(stored_array, input_array)
  # here be dragons
end
</code></pre>

<p>All I need to do is to give the reader some clue that it&rsquo;s a performance hack, and then they can read more in
the commit message if they want.</p>

<h3>Reminder / TODO</h3>

<p>Writing <code>TODO</code> or <code>FIXME</code> somewhere in the codebase creates
a bit of a <a href="http://en.wikipedia.org/wiki/Bystander_effect">bystander effect</a>. It seems like the intent of the
TODO is that &ldquo;someone will surely see this code and proactively delete it&rdquo;, but in reality that will
never happen. Every time someone goes into that section of the code, they&rsquo;re in there for some other purpose
and they&rsquo;re going to ignore your TODO. This is especially true on bigger teams.</p>

<p>Example:</p>

<pre><code class="ruby">require 'mylibrary/railtie' if defined?(Rails) # TODO: older rails support!
</code></pre>

<p>Realistically, when is that TODO ever going to get done? A better solution would be to use some project management
tool to prioritize different features or fixes. If you have to keep your <code>TODO</code>s in the code, use the
<a href="https://github.com/andyw8/do_by">doby</a> library, or roll your own expiring todos.</p>

<pre><code class="ruby">TODO 'older rails support!', '2014-09-01'
require 'mylibrary/railtie' if defined?(Rails)
</code></pre>

<p>This method sets a specific due date for the <code>TODO</code>, and, unlike a regular comment, it actually gets executed
and blows up if you haven&rsquo;t removed it before the due date. (Buyer beware: you probably only want this behavior
in dev.)</p>

<h3>Old code you &ldquo;want to keep around&rdquo; in case you need it</h3>

<p>This is by far the worst commenting infraction! You might see a comment like:</p>

<pre><code class="ruby"># def reslug_all_tag_pages
#   Tag.find_each { |t| t.regenerate_slug! }
# end

def something_else_thats_actually_being_used
  ...
end
</code></pre>

<p>&ldquo;Keeping around old code you might want to use later&rdquo; is <em>exactly</em> what source control is for. If you want
to resurrect some old code, you can do so easily with git as long as you can remember some part of the
code. Let&rsquo;s say you want to resurrect this <code>reslug_all_tag_pages</code> method. Just use:</p>

<pre><code class="sh">$ git log -Sreslug_all_tag_pages
</code></pre>

<p>and that will find all commits that added or deleted a line including that string. Simple!</p>

<h3>Automatically generated comments</h3>

<p>It&rsquo;s less common in the world of dynamic languages, but the most popular IDEs for compiled
languages tend to pepper the codebase with these useless automatically generated strings. They generate these
comments to remind programmers to document their APIs, but I&rsquo;ve frequently seen developers commit
the automatically generated documentation on a method or class without modification. Some examples:</p>

<pre><code class="java">public class MyList&lt;E&gt; extends ArrayList&lt;E&gt; {

  private int myVar;

  /**
   * @return the myVar
   */
  public int getMyVar() {
    return myVar;
  }

  /**
   * @param myVar the myVar to set
   */
  public void setMyVar(int myVar) {
    this.myVar = myVar;
  }

  /* (non-Javadoc)
   * @see java.util.ArrayList#addAll(java.util.Collection)
   */
  @Override
  public boolean addAll(Collection&lt;? extends E&gt; collection) {
    // something
  }

}
</code></pre>

<p>The generated comments do nothing but clutter up the code, making it more difficult for the reader to scroll
through the class and figure out what the code is doing.</p>

<h3>Is there ever a reason to write a comment?</h3>

<p>To be clear, I don&rsquo;t have a problem with all comments. If you&rsquo;re writing a public API for
a library that&rsquo;s getting exported to the world, or to a bunch of developers at your company, it may be
easiest to maintain the documentation for that API in code comments. In other words, if you&rsquo;re making a
conscious decision to document a library thoroughly, you might find that it&rsquo;s most convenient to keep that
documentation close to the code. In that case, you should have some kind of process for making sure that
the documentation remains up to date when you make breaking API changes. You should also be able to easily
generate structured documentation from those code comments.  (<a href="http://rdoc.sourceforge.net/">RDoc</a> for Ruby
is one simple example)</p>

<h3>Leave &lsquo;em out</h3>

<p>Comments decay. They aren&rsquo;t compiled, and they&rsquo;ll never get executed at runtime. If they become out of date or
incorrect, no test is going to fail and no user is going to complain.
Programmers work around them out of fear that &ldquo;somebody might need this comment or it might provide some value
in the future&rdquo;, pushing them along far after they&rsquo;re useful (if you can even argue that they were useful in
the first place).</p>

<p>Writing a comment to explain your code is the easy way out. It is more difficult to write expressive code than it is
to write a paragraph explaining it, but taking the time to write code that speaks for itself pays huge dividends in
the long run.</p>

<p>So now that I&rsquo;ve covered all of these examples, you don&rsquo;t have any excuse to write comments. Give these
methods a try, and I promise you&rsquo;ll have a cleaner codebase that&rsquo;s easier to maintain. Is there a good reason
to write a comment that I&rsquo;ve missed? Let me know in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Choosing a new theme]]></title>
    <link href="http://www.leastastonished.com/blog/2014/08/13/choosing-a-new-theme/"/>
    <updated>2014-08-13T23:25:46-04:00</updated>
    <id>http://www.leastastonished.com/blog/2014/08/13/choosing-a-new-theme</id>
    <content type="html"><![CDATA[<p>About a week ago I finally decided that I wanted to start blogging again. I love talking about programming, but I often find it
difficult to motivate myself to write a blog post about it. I sat down to write a post, and sure enough, I couldn&rsquo;t think of anything
to blog about. So instead I procrastinated by thinking about all of the things I wanted to do to make my blog better.</p>

<!-- more -->


<p>The most obvious problem was that I was still using the default <a href="https://github.com/imathis/octopress">Octopress</a> theme.
It has a lot of nice qualities: it&rsquo;s easy to navigate around, easy to read, and it&rsquo;s responsive! Unfortunately,
using the default theme meant that my site also looked exactly like
<a href="https://github.com/imathis/octopress/wiki/Octopress-Sites">everyone else&rsquo;s</a>.</p>

<p>Now Octopress is also great because it&rsquo;s extremely easy for anyone to make a theme. In fact, a
<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">bunch of people</a> have already done exactly that. Looking at the
list of themes, though, I realized that it was difficult to tell which ones were &ldquo;the good ones.&rdquo; Normally when I have a huge list of
products that I want to comb through, I&rsquo;m on a website where I can easily sort by some metadata about the product. (e.g. Amazon)
My preferred sort is always by popularity: I basically trust the wisdom of the crowd. On Amazon, for example, I&rsquo;m much more interested
in the product with the most reviews than I am in the product with the best average review. Unfortunately, GitHub tables have no such
convenient sorting options!</p>

<p>Luckily, I&rsquo;m a programmer, and, wanting to procrastinate more, I decided that I wanted to write a quick script to sort projects by
number of stars. As it turns out, it&rsquo;s pretty simple to use <a href="http://nokogiri.org/">Nokogiri</a> and <a href="https://github.com/octokit/octokit.rb">Octokit</a> to get the information I want:</p>

<p><div><script src='https://gist.github.com/60afe3ffdd0872719247.js'></script>
<noscript><pre><code>require 'nokogiri'
require 'octokit'
require 'open-uri'

github = Octokit::Client.new(:access_token =&gt; ENV['GH_TOKEN'])

doc = Nokogiri::HTML.fragment(open('https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes').read)

doc.search('table tr td:first a:first').map do |a|
  a['href'] =~ %r{https?://github.com/([^/]+)/([^?/]+)(\?|$|/)} &amp;&amp; [$1, $2]
end.compact.map do |owner, repo_name|
  begin
    github.repository(:owner =&gt; owner, :name =&gt; repo_name)
  rescue Octokit::NotFound
  end
end.compact.sort_by { |repo| -repo.stargazers_count }.each do |repo|
  puts &quot;#{repo.html_url} - #{repo.stargazers_count}&quot;
end</code></pre></noscript></div>
</p>

<p>This script simply:</p>

<ul>
<li>scrapes the <a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">themes page</a></li>
<li>parses it with Nokogiri</li>
<li>finds the table with the themes</li>
<li>selects the link from the first column of each row, which is the link to the theme repository on GitHub</li>
<li>extracts the owner and repo name using a &ldquo;simple&rdquo; regular expression</li>
<li>maps owner/repo to number of stars</li>
<li>prints a sorted list of repo links and stars</li>
</ul>


<p>and voila, we have an Amazon-like sort by popular-type situation. (check out the results in the <a href="https://gist.github.com/a-warner/60afe3ffdd0872719247">gist comments</a>)</p>

<p>After checking out the popular themes, I decided, contrary to my usual shopping strategy, that I wasn&rsquo;t in love with any of them.
I was looking for something simple, single-column, and easy to read. I ended up settling on
<a href="https://github.com/mjhea0/whiterspace">whiterspace</a>, which, even though it only had 45 stars, was exactly what I was looking for.</p>

<p>So, while I didn&rsquo;t end up choosing the most popular theme, it was still useful to be able to look at a mapping of themes to popularity.
In the end, whiterspace got one more star, and I got a cleaner, more distinct-looking blog. Oh, and in doing all of this work, I ended up with a
somewhat interesting topic to blog about (I hope!), accomplishing my original goal in a somewhat roundabout way. Win win win!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The 3 Ways to Get the Size of an Active Record Relation]]></title>
    <link href="http://www.leastastonished.com/blog/2013/04/21/the-3-ways-to-get-the-size-of-an-active-record-relation/"/>
    <updated>2013-04-21T18:14:00-04:00</updated>
    <id>http://www.leastastonished.com/blog/2013/04/21/the-3-ways-to-get-the-size-of-an-active-record-relation</id>
    <content type="html"><![CDATA[<p>If you&rsquo;re reading this and your first thought is, &ldquo;there are 3 ways to get the size of a relation?&rdquo;, then
you&rsquo;ve come to the right place! Basically, given a relation like <code>Post.all</code> or <code>User.first.posts</code>, when you
want to know the size, you&rsquo;ve got 3 choices: <code>size</code>, <code>length</code>, and <code>count</code>.  At first glance, it seems like these
might do the same thing, right?  Not so!  There are some key differences between them.</p>

<!-- more -->


<p>TL;DR - use <code>size</code>, it usually &ldquo;Does the Right Thing&rdquo;</p>

<p>First off, some background: both <code>Post.all</code> and <code>User.first.posts</code> are instances of <code>ActiveRecord::Relation</code>,
a very sneaky and
powerful class which manages lazy loading of records from the database. (full disclosure, <code>User.first.posts</code> is
actually an instance of <code>ActiveRecord::Associations::CollectionProxy</code>, but the difference between the two isn&rsquo;t
really relevant to this article).  It makes a best effort to filter, and
order records until the last possible minute when you actually ask for something concrete.  It&rsquo;s that lazy loading
which allows you to write code like <code>Post.where(featured: true).order(created_at: :desc).paginate(page: 1)</code>, which
will generate only one query for the first page of posts.  If you want to get the size of a Relation, there are
3 different ways to ask for it:</p>

<h3>length</h3>

<p>The simplest of the three methods, <code>length</code> is simply delegated to <code>to_a</code> on the collection; in other words, calling
length is equivalent to calling <code>Post.all.to_a.length</code>.  It will query for ALL records, initialize ruby objects for
all of them, and then get the size of the array.  Probably not what you want if you just want to display the count
of the Posts on your blog!</p>

<h3>count</h3>

<p>Does a sql <code>count(*)</code> query for the count of the records in the database.  You probably want to use this method
if you only ever need the count of the records in the association for whatever you&rsquo;re doing.  In the example above,
just displaying a count on the page is a perfect use case for <code>count</code>.</p>

<h3>size</h3>

<p>Size makes a best effort attempt to &ldquo;Do The Right Thing&rdquo; based on the current state of the collection.  Here is the
actual source for size:</p>

<p>From <a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/relation.rb#L205">ActiveRecord::Relation</a>:
<code>ruby lib/active_record/relation.rb
  # Returns size of the records.
  def size
    loaded? ? @records.length : count
  end
</code></p>

<p>Great comment by the way, I never would have known what <code>size</code> did without it.</p>

<p>Basically, size is a heuristic switch between <code>length</code> and <code>count</code>.  If the collection is loaded, it just
gets the length of the loaded array, otherwise it will hit the database with a query.  As pointed out in a
<a href="https://github.com/rails/rails/blob/master/activerecord/lib/active_record/associations/collection_proxy.rb#L677">much more informative comment which is for some reason in the CollectionProxy object instead</a>,
you&rsquo;ll end up with an extra query if you call <code>size</code> and then actually need the elements of the collection later.</p>

<p>In a lot of cases the differences are completely irrelevant, but, for my money, <code>size</code> is the best of the 3 options.
It does the best job of not leaking details about what&rsquo;s going on under the hood in terms of lazy loading in Active
Record.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use the Rails Router for Routing!]]></title>
    <link href="http://www.leastastonished.com/blog/2013/04/21/use-the-rails-router-for-routing/"/>
    <updated>2013-04-21T17:41:00-04:00</updated>
    <id>http://www.leastastonished.com/blog/2013/04/21/use-the-rails-router-for-routing</id>
    <content type="html"><![CDATA[<p>This is a quick one, and the title says most of it.  Basically, you should never have code like this in
your app:</p>

<pre><code class="ruby some_controller.rb">class SomeController &lt; ApplicationController
  def some_action
    if something_about_the_url?
      do_something
      render :template =&gt; :foo
    else
      do_something_else
      render :template =&gt; :baz
    end
  end
end
</code></pre>

<!-- more -->


<p>The whole point of the router is to handle stuff about the url!  Instead, move whatever the logic inside
<code>something_about_the_url?</code> does upstream to the router layer.  For example, say you want to display a different
home page for www.mysite.com and blog.mysite.com.  This can be accomplished very easily using the router:</p>

<pre><code class="ruby routes.rb">constraints subdomain: 'blog' do
  root to: 'blog#home'
end

root to: 'static#home'
</code></pre>

<p>Note that, in this specific case, you must have the subdomain route above the <code>root</code> route, otherwise the router
will match the route to <code>static#home</code> before it gets to the subdomain constraint.  Remember that the router
checks routes in order.  All set!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Active Record Query Debugging in the Rails Console]]></title>
    <link href="http://www.leastastonished.com/blog/2013/03/17/simple-active-record-query-debugging-in-the-rails-console/"/>
    <updated>2013-03-17T18:22:00-04:00</updated>
    <id>http://www.leastastonished.com/blog/2013/03/17/simple-active-record-query-debugging-in-the-rails-console</id>
    <content type="html"><![CDATA[<p>Stop me if this sounds familiar.  You&rsquo;re tooling around in the Rails console, testing out some new code you&rsquo;re working on (or debugging some slow/broken code), and you see a ton of repeat queries.</p>

<p>I have this experience frequently; usually I can figure out what&rsquo;s going on, but sometimes it can be quite tricky to track down the source of extra queries.  Whenever I want to figure out where a method is getting called from, one easy and lazy solution is to add a debugger statement in that code.  But where the heck do I add a debugger for sql statements?</p>

<!-- more -->


<p>It turns out that Active Record has a fairly unified choke-point for query execution on a per-model basis - <code>#find_by_sql</code>.  So, now that we know the method, what&rsquo;s the best way to add the debugger statement?  Well, we <em>could</em> just open up the gem code, but then we have to restart our console, and we run the risk of forgetting to remove the statement or otherwise screwing up the gem code in some way that&rsquo;s difficult to track down.  We could monkey patch the method, but even that sounds onerous, especially if we want the method to be usable again without hitting that debugger statement later in our session.</p>

<p>Enter a relatively short addition to your <code>.irbrc</code> or <code>.pryrc</code>!  Simply add the following method:</p>

<pre><code class="ruby">def add_debugger(clazz, method)
  debugger_method = binding.respond_to?(:pry) ? 'binding.pry' : 'debugger'

  unless clazz.method_defined? "#{method}_with_debugger"
    clazz.class_eval &lt;&lt;-CODE, __FILE__, __LINE__ + 1
      def #{method}_with_debugger(*args, &amp;block)
        #{debugger_method}
        #{method}_without_debugger(*args, &amp;block)
      end
      alias_method_chain :#{method}, :debugger
    CODE
  end
end
</code></pre>

<p>Note that my debugger preference is <code>pry</code>, if it&rsquo;s available.  You can of course adjust the above code per your preference.  Now we can simply run:</p>

<pre><code class="ruby">add_debugger MyModel.singleton_class, :find_by_sql
</code></pre>

<p>Running through our problem code again, you should find yourself in the debugger for any queries on <code>MyModel</code>.  Once in the debugger, simply inspect <code>caller</code> to figure out what pesky bit of code is generating all of the extra queries.</p>

<p>This is great, but it would incomplete if we had to restart the server in order to remove the debugger statement!  The following snippet should do the trick:</p>

<pre><code class="ruby">def remove_debugger(clazz, method)
  return unless clazz.method_defined? "#{method}_with_debugger"

  clazz.class_eval do
    alias_method method, "#{method}_without_debugger"
    undef_method "#{method}_with_debugger"
    undef_method "#{method}_without_debugger"
  end
end
</code></pre>

<p>Just run <code>remove_debugger MyModel.singleton_class, :find_by_sql</code>, and you&rsquo;re back to regular development.</p>

<p>Now that you&rsquo;ve got this method, adding debugging statements to your own code or 3rd party code is a breeze!</p>

<p>Check out my <a href="https://github.com/a-warner/dotfiles/blob/master/.railsrc">.railsrc</a> for more little one-off development helper methods.</p>

<p>Is there an easier way to do this with pry?  Is there a gem that just does this and makes my silly code obsolete?  Let me know in the comments!</p>
]]></content>
  </entry>
  
</feed>
